pos =~ SPANE1 + SPANE3 + SPANE5 + SPANE7 + SPANE10 + SPANE12
neg =~ SPANE2 + SPANE4 + SPANE6 + SPANE8 + SPANE9 + SPANE11
SPANE7 ~~ SPANE10
'
posneg.ordinal.fit.mod <- sem(posneg.ordinal.model.mod, data = posneg.data,
sample.nobs = 4250,
ordered = TRUE, std.lv = TRUE)
fit.indices.posneg.ordinal.fit.mod <- fitMeasures(posneg.ordinal.fit.mod)
posneg.ordinal.fit.mod
summary(posneg.ordinal.fit.mod)
# install.packages("semPlot")
library(lavaan)
library(semPlot)
model.neuro.cov = '
factor=~Y1+Y2+Y3+Y4+Y5+Y6+Y7+Y8+Y9+Y10'
res.neuro.cov = sem(model.neuro.cov,sample.cov = neuro_cov, sample.nobs = 1000,
meanstructure = TRUE, std.lv = TRUE, sample.mean = neuro_me)
neuro_cov = as.matrix(read.table("neuroticism.cov", header=TRUE))
neuro_me = as.matrix(read.table("neuroticism.me", header=TRUE))
# question 1a
getwd()
library(shiny)
library(bslib)
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
runApp("my_app")
getwd()
setwd("~/Documents/GitHub/programming-intake-interface/intakegui/R")
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
runApp("R")
getwd()
runApp("/Users/airevaliente/Documents/GitHub/programming-intake-interface/intakegui/R")
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
runApp("app.R")
getwd()
runApp("app.R")
getwd()
setwd("~/Documents/GitHub/programming-intake-interface/intakegui")
getwd()
library(shiny)
library(bslib)
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
#' Add two numbers
#' @param a
#' @param b
#' @details adds a to b.
add_a_and_b <- function(a, b) {
a + b
}
devtools::document()
devtools::install(".")
library(intakegui)
?add_a_and_b
?add_a_and_b
devtools::document()
devtools::install(".")
library(intakegui)
?add_a_and_b
library(shiny)
library(bslib)
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
#' @param a First number
#' @param b Second number
#'
#' @return The sum of \code{a} and \code{b}.
#'
#' @examples
#' add_a_and_b(2, 3)
#' add_a_and_b(10, -5)
#'
#' @export
add_a_and_b <- function(a, b) {
a + b
}
devtools::document()
library(intakegui)
?add_a_and_b
library(shiny)
library(bslib)
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
#' @param a First number
#' @param b Second number
#'
#' @return The sum of \code{a} and \code{b}.
#'
#' @examples
#' add_a_and_b(2, 3)
#' add_a_and_b(10, -5)
#'
#' @export
add_a_and_b <- function(a, b) {
a + b
}
devtools::document()
devtools::install(".")
rm(list = c("add_a_and_b"))
?add_a_and_b
roxygen2::roxygenize()
#' @param a First number
#' @param b Second number
#'
#' @return The sum of \code{a} and \code{b}
#'
#' @examples
#' add_a_and_b(2, 3)
#'
#' @export
#' @importFrom stats rnorm
add_a_and_b <- function(a, b) {
a + b
}
#'
#' @param n Number of random values to generate
#'
#' @return A numeric vector of random values
#'
#' @examples
#' generate_noise(5)
#'
#' @export
#' @importFrom stats rnorm
generate_noise <- function(n) {
rnorm(n)
}
roxygen2::roxygenize()
rm(list = c("add_a_and_b"))
devtools::install(".")
library(intakegui)
add_a_and_b(4, 5)
generate_noise(3)
?add_a_and_b
?generate_noise
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    https://shiny.posit.co/
#
library(shiny)
library(bslib)
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
#' Add two numbers
#'
#' This function adds two numeric values together.
#'
#' @param a First number
#' @param b Second number
#'
#' @return The sum of \code{a} and \code{b}.
#'
#' @examples
#' add_a_and_b(2, 3)
#' add_a_and_b(10, -5)
#'
#' @export
add_a_and_b <- function(a, b) {
a + b
}
#' Add two numbers
#'
#' Adds two numbers and returns the sum.
#'
#' @param a First number
#' @param b Second number
#'
#' @return The sum of \code{a} and \code{b}
#'
#' @examples
#' add_a_and_b(2, 3)
#'
#' @export
#' @importFrom stats rnorm
add_a_and_b <- function(a, b) {
a + b
}
#' Generate random numbers
#'
#' @param n Number of random values to generate
#'
#' @return A numeric vector of random values
#'
#' @examples
#' generate_noise(5)
#'
#' @export
#' @importFrom stats rnorm
generate_noise <- function(n) {
rnorm(n)
}
roxygen2::roxygenize()
rm(list = c("add_a_and_b"))
devtools::install(".")
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    https://shiny.posit.co/
#
library(shiny)
library(bslib)
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
#' @param a First number
#' @param b Second number
#'
#' @return The sum of \code{a} and \code{b}.
#'
#' @examples
#' add_a_and_b(2, 3)
#' add_a_and_b(10, -5)
#'
#' @export
add_a_and_b <- function(a, b) {
a + b
}
#'
#' @param n Number of random values to generate
#'
#' @return A numeric vector of random values
#'
#' @examples
#' generate_noise(5)
#'
#' @export
#' @importFrom stats rnorm
generate_noise <- function(n) {
rnorm(n)
}
roxygen2::roxygenize()
getwd()
